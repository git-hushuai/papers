+ 关于多线程技术会带来的那些问题

如果没有多线程技术，那么我们要对一张照片进行滤镜处理时，那么我们队一张照片进行滤镜处理时，就只能有主线程来完成这个处理，可想而知，这时候主线程阻塞了，其它的任何操作都无法继续。

解决这个问题，就要再多创建一个来进行滤镜处理的操作，这样主线程就可以继续执行其它操作，这里用到的就是多线程技术了。


目前，在iOS开发中，我们经常会用到系统提供的方法来使用多线程技术开发App，期望可以充分利用硬件资源来提高App的运行效率。

但是，我们不禁会想到，像UIKit这样的前端框架并没有使用多线程技术，而AFNetworking 2.0（网络框架）、FMDB这些用得最多的基础库，使用多线程技术也是非常谨慎。


当你学了多线程的相关知识后，一定会忍不住去使用多线程，但在使用时一定要小心多线程的那些陷阱，只有这样，我们在使用多线程技术时才能预见到可能出现的问题。

而写UIKit、AFNetworking、FMDB这些库的大佬们，并不是解决不了多线程技术可能会带来的问题，而相反正是因为他们非常清楚这些可能存在的问题，所以为了避免使用者滥用多线程，亦或是出于性能考虑，而选择了使用单一线程来保证这些基础库的稳定可用。


那这样说的话，为了稳定我们就不能使用多线程技术了吗？


当然不是，多线程技术还是有很多适用场景的。就比如说，在需要快速进行多个任务计算的场景里，多线程技术确实能够明显提高单位时间内的计算效率。

还是以照片处理为例，当选择一张照片后，你希望能够看到不同滤镜处理后的效果。如果这些效果图都是在一个队列里串行处理的话，那么你就得等着这些滤镜一个一个地来处理。这么做的话，不仅会影响用户体验，也没能充分利用硬件资源，可以说是把高端手机当作低端机来用了。换句话说就是，用户花大价钱升级了手机硬件，操作 App 的体验却没有得到提升。

所以，我们不能因为多线程技术有坑就不去用，正确的方法应该是更多地去了解多线程会有哪些问题，如果我们能够事先预见到那些问题的话，那么避免这些问题的发生也就不在话下了。


接下来，我们就一起来看看多线程技术常见的两个大坑，常驻线程和并发问题，分别是从何而来，以及如何避免吧。


#### 常驻线程


**常驻线程：** 指的是那些不会停止，一直存在于内存中的线程，我们在文章开始部分，说到的 AFNetworking 2.0 专门创建了一个线程接收NSOperationQueue的回调，这个线程其实就是一个常驻线程，接下来，我们就看看常驻线程这个问题是如何引起的，以及是否有对应的解决方案。

我们先通过AFNetworking 2.0 创建常驻线程的代码，来看一下这个线程是怎么创建的

```
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        // 先用 NSThread 创建了一个线程
        [[NSThread currentThread] setName:@"AFNetworking"];
        // 使用 run 方法添加 runloop
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}
```

如代码所示，AFNetworking 2.0 先用NSThread创建了一个线程，并使用NSRunLoop的run方法给这个新线程添加了一个runloop。

通过NSRunLoop添加runloop的方法有三个：

+ run方法，通过run方法添加的runloop，会不断地重复调用runMode:beforeDate:方法，来保证自己不会停止。

+ runUntilDate：和runMode：beforeDate方法，这两个方法添加的runloop，可以通过指定时间来停止runloop。

写到这里，可以看到，原来创建一个常驻线程这么容易，那么我每写一个库就创建一个常驻线程来专门处理当前库自己的事情，该多好，大名鼎鼎的 AFNetworking 2.0 库就是这么干的。

但是，再想想，如果你有三十个库，每个库都常驻一个线程，这样做，不但不能提高CPU的利用率，反而会降低程序的执行效率，也就是说，这样做的话，就不是充分利用而是浪费CPU资源了。

那么**既然常驻线程是个坑，那么为什么AFNetworking 2.0 库还要那么做呢？**

其实，这个问题的根源在于AFNetworking 2.0 使用的是NSURLConnection，而NSURLConnection的设计上存在些缺陷，了解了这些缺陷后你也就能够理解当时AFNetworking 2.0 为什么明知常驻线程有坑，还是使用常驻线程，这样，你以后碰到类似的情况时，也可以跟AFNetworking 2.0 一样使用常驻线程去解决问题，只要不滥用常驻线程就可以了。


NSURLConnection发起请求后，所在的线程需要一直存活，以等待接收NSURLConnectionDelegate 回调方法。但是，网络返回的时间不确定，所以这个线程就需要一直常驻在内存中，既然这样，AFNetworking2.0 为什么没有在主线程上完成这个工作，而一定要新创建一个线程来做呢？

这是因为主线程还要处理大量的UI的交互工作，为了减少对主线程的影响，所以AFNetworking2.0 就新创建了一个常驻线程，用来处理所有的请求和回调，AFNetworking2.0 的线程设计如下图所示：

![](https://static001.geekbang.org/resource/image/02/48/02c4b5f2f0a9a2d0cef55b9e5420e148.png)


通过上面的分析我们可以知道，如果不是因为NSURLConnection的请求必须要有一个一直存活的线程来接收回调，那么AFNetworking2.0 就不用创建一个常驻线程出来了，虽然说，在一个App里网络请求这个动作的占比很高，但也有很多不需要网络的场景，所以线程一直常驻在内存中，也是不合理的。

但是，AFNetworking 在 3.0 版本时，使用苹果公司推出的NSURLSession替换了NSURLConnection，从而避免了常驻线程这个坑，NSURLSession可以指定回调NSOperationQueue，这样请求就不需要让线程一直常驻在内存里去等待回调了，实现代码如下：

```
self.operationQueue = [[NSOperationQueue alloc] init];
self.operationQueue.maxConcurrentOperationCount = 1;
self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];
```

从上面的代码可以看出，NSURLSession发起的请求，可以指定回调的delegateQueue，不在需要在当前线程进行代理方法的回调，所以说，NSURLSession解决了NSURLConnection的线程回调问题。

可见，AFNetworkning 2.0 使用常驻线程也是无奈之举，一旦有方案能够替代常驻线程，它就会毫不犹豫地废弃常驻线程，那么，你还有什么理由要使用常驻线程呢？

如果**你需要确实需要保活时长，让线程存活时间可预期，总比让线程常驻，至少在硬件资源利用率上更加合理**

或者，你还可以使用CFRunLoopRef 的 CFRunLoopRun 和 CFRunLoopStop 方法来完成runloop的开启和停止，达到将线程保活一段时间的目的。


#### 并发

并发是多线程技术的第二坑

在iOS并发编程技术中，GCD的使用率是最高的，所以，在这篇文章中，我就以GCD为例说说多线程的并发问题。


GCD（Grade Central Dispatch）是由苹果公司开发的一个多核编程解决方案。它提供的一套简单易用的接口，极大地方便了并发编程，同时，它还可以完成对复杂的线程创建，释放时机的管理，但是，GCD带来这些便利的同时，也带来了资源使用上的风险。

例如：在进行数据读写操作时，总是需要一段时间来等待磁盘响应的，如果在这个时候通过GCD发起了一个任务，那么GCD就会本着最大利用CPU的原则，会在等待磁盘响应的这个空档，再创建一个新线程来保证能够充分利用CPU。

而如果GCD发起的这些新任务，都是类似于数据存储这样需要等待磁盘响应的任务的话，那么随着任务数量的增加，GCD创建的新线程就会越来越多，从而导致内存资源越来越紧张，等到磁盘开始响应的时候，再读取数据又会占用更多的内存，结果就是，失控的内存会引起更多的内存问题。

这种情况典型的场景就是数据库读写操作，FMDB是一个开源的第三方数据库框架，通过FMDatabaseQueue这个核心类，将与读写相关的磁盘操作都放到一个串行队列里执行，从而避免了线程创建过多导致资源紧张的情况。


#### 内存问题

在并发这部分，我们说线程开多了会有内存问题，那到底是什么内存问题呢？ 为什么会有内存问题呢？

我们知道，创建线程的过程，需要用到物理内存，CPU也会消耗时间，而且，新建一个线程，系统还需要为这个进程空间分配一定的内存作为线程堆栈，堆栈大小是4KB的倍数，在iOS开发中，主线程堆栈大小是1MB，新创建的子线程堆栈大小是512KB。



除了内存开销外，线程创建得多了，CPU在切换线程上下文时，还会更新寄存器，更新寄存器的时候需要寻址，而寻址的过程还会有较大的CPU消耗。

所以，线程过多时内存和CPU都会有大量的消耗，从而导致App的整体性能降低，使得用户体验变差，CPU和内存的使用超出系统限制时，甚至会造成系统强杀，这种情况对用户和App的伤害就更大了













