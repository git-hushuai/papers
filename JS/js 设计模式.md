#### 设计模式手册之模板模式

##### 1. 什么是模板模式

> 模板模式是抽象父类定义了子类需要重写的相关方法，而这些方法，仍然是通过父类方法调用的。

根据描述，“模板”的思想提现在：父类定义的接口方法。除此之外，子类方法的调用，也是被父类控制的。


##### ES6 实现

__Animal__ 是抽象类，Dog和Cat分别具体实现了eat()和sleep()方法。

__Dog__或__Cat__实例可以通过live()方法调用eat()和sleep()。

__注意：__Cat和Dog实例会被自动添加live()方法。不暴露live()是为了防止live()被子类重写，保证父类的控制权。


```
		class Animal{
			constructor(){
				this.live = ()=>{
					this.eat();
					this.sleep();
				}
			}

			eat(){
				throw new Error("模板类方法必须被重写");
			}

			sleep(){
				throw new Error("模本类方法必须被重写");
			}
		}

		class Dog extends Animal{
			constructor(...args){
				super(...args);
			}

			eat(){
				console.log("狗吃粮");
			}

			sleep(){
				console.log("狗睡觉");
			}
		}


		class Cat extends Animal{
			constructor(...args){
				super(...args);
			}

			eat(){
				console.log("猫吃粮");
			}

			sleep(){
				console.log("猫睡觉");
			}
		}


		let dog = new Dog();
		dog.live();
```

#### 设计模式手册之备忘录模式

##### 1. 什么是备忘录模式

> 它属于行为模式，保存某个状态，并且在需要的时候直接获取，而不是重复计算；

__注意:__ 备忘录模式实现，不能破坏原始封装。也就是说，只能拿到内部状态，将其保存在外部。

##### 2. 应用场景

> 最典型的例子就是“斐波那契数列”递归实现。
> 
> 不借助备忘录模式，数据一大，就容易爆栈；借助备忘录，算法的时间复杂度可以降低到O(N)
> 
> 

#### 设计模式手册之备桥接模式

##### 1. 什么是桥接模式

> 桥接模式将抽象部分和具体实现部分分离，两者可独立变化，也可以一起工作。

在这种模式的实现上，需要一个对象担任__桥__的角色，起到桥接的作用；

#### 2. 应用场景

在封装开源库组件的时候，经常会用到这种设计模式：

例如：对外提供暴露一个afterFinish函数,如果用户有传入此函数，那么就会在某一段代码逻辑中调用，这个过程中，组件起到了“桥”的作用，而具体实现是用户自定义。

#### 3. 多语言实现

###### 3.1 ES6实现

Javascript 中桥接模式的典型应用是：Array对象上的forEach函数：此函数复杂循环遍历数组每个元素，是抽象部分；而回调函数callback就是具体的实现部分：

下面是模拟forEach方法：

```
	const forEach = (arr , callback) => {
	
		if(!Array.isArray(arr))return;
		
		const length = arr.length;
		for(let i = 0; i < length ; ++i){
			callback(arr[i],i)
		}
	};
```

#### 设计模式手册之适配器模式

##### 什么是适配器模式

> 适配器模式为多个不兼容的接口之间提供”转化器“；

> 它的实现非常简单，检查接口的数据，进行过滤、重组等操作，使另一个接口可以使用数据即可；
> 

##### 应用场景

> 当数据不符合使用规则，就可以借助此种模式进行格式转化；
> 
> 

#### 设计模式手册之状态模式

#####  什么是”状态模式“ 

> 状态模式：对象行为是__基于状态__来改变；
> 
> 内部的状态变化，导致了行为表现形式不同。所以，用户在外面看起来，好像是修改了行为；
> 


##### 优缺点：

> 优点： 封装了转化规则，对于大量分支语句，可以考虑使用状态类进行进一步封装；每个状态都是确定的，所以对象行为是可控的。
> 
> 缺点：状态模式的__关键__是将事物的状态都封装成单独的类，这个类的各种方法就是”此种状态对应的表现行为，因此状态类会增加__程序开销__
> 
> 

#### 设计模式手册之装饰者模式

##### 1.什么是”装饰者模式“

> 装饰者模式：在不改变对象自身的基础上，动态地添加功能代码。
> 
> 根据描述，装饰者显然比继承等方式更灵活，而且__不污染__原来的代码，代码逻辑松耦合。
> 

##### 2. 应用场景

装饰者模式由于松耦合，多用于一开始不确定对象的功能，或者对象功能经常变动的时候。尤其是在__参数检查__、__参数拦截__等场景。

#### 设计模式手册之责任链模式

##### 1. 什么是责任链模式

> 责任链模式：多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系。这些对象连接成为链式结构，每个节点转发请求，直到有对象处理请求为止。


其核心就是：请求者不知道是那个对象处理的请求，如果当前不符合终止条件，那么把请求转发给下一个节点处理。而当需求具有”传递“性质时，（代码中其中一种体现就是：多个if、esle if、else if、else 嵌套）就可以考虑将每个分支拆分成一个节点对象，拼接成为责任链。


#### 2. 优点和代价

######  1. 可以根据需求变动，任意向责任链中添加、删除节点对象； 
######  2. 没有固定的”开始节点“，可以从任意节点开始；


+ 代价：责任链最大的代价就是每个节点带来的多余消耗。当责任链过长，很多的节点只有传递的作用，而不是真正地处理逻辑。



#### 设计模式手册之享元模式


> 享元模式：运用共享技术来减少创建对象的数量，从而减少内存占用、提高性能；
> 

1. 享元模式提醒我们将一个__对象的属性划分为内部和外部状态。__

	+ 内部状态：可以被对象集合共享，通常不会改变
	+ 外部状态：根据应用场景经常改变。

2. 享元模式是利用时间换取空间的优化模式



