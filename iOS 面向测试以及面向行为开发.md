###### 虽说一般公司都会有专门的测试团队对产品进行大量测试，但是如果不能在开发阶段及时发现问题，当各团队代码集成到一起，把所有问题都堆积到测试阶段去发现、解决，就会浪费大量的沟通时间，不光是开发同学和测试同学之间的沟通时间，还有开发团队之间的沟通时间也会呈指数级增加。

那么，有没有什么好的开发方式，能够提高在编写代码后及时检验结果的效率呢？

所谓好的开发，就是开发、测试同步进行，尽早发现问题，从测试范围和开发模式的角度。我们还可以把这种开发模式细分出更多类型。


**从测试返回上来划分的话**，软件测试可以分为单元测试。集成测试、系统测试。测试团队负责的是集成测试以及系统测试，而单元测试是由开发者负责的，对于开发者来说，通过单元测试就可以有效提高编写代码后快速发现问题的效率。

概况来说：单元测试，也叫模块测试，就是对单一的功能代码进行测试，这个功能代码，可能是一个类的方法，也可能是一个模块的某个函数。


单元测试会使用Mock方式模拟外部使用，通过编写的各种测试用例去检验代码的功能是否正常。一个系统都是由各个功能组合而成，功能模块划分的越小，功能职能就越清晰，清晰的功能职责可以确保单个功能的测试不会出现问题，是单元测试的基础。

**从开发模式划分的话，**开发方式可以分为TDD（Test-driven development，面向测试驱动开发）和BDD（Behavior-driver development，面向行为开发）。

+ TDD 的开发思路是：先编写测试用例，然后在不考虑代码优化的情况下快速编写功能实现代码，等功能开发完成后，在测试用例的保障下，再进行代码重构，以提高代码质量。


+ BDD是TDD的进化，基于行为进行功能测试，适合单元测试。而BDD的测试用例是对行为的描述，测试范围可以更大一些，在集成测试和系统测试时都可以使用，同时，不仅开发者可以使用BDD的测试用例高效地发现问题，测试团队也能很容易的参与编写，这都得益于BDD可以使用易于编写行为功能测试的DSL语言。

### TDD

我们刚刚提到：TDD在确认功能需求后，首先就会开始编写测试用例，用来检验每次的代码更新，能够让我们更快地发现问题，并能保证不会漏掉问题，其实，这就是通过测试用例来推动开发。


在思想上，和拿到功能需求后直接开发功能的区别是，TDD会先考虑如何对功能进行测试，然后再去考虑如何编写代码，这就给优化代码提供了更多的时间和空间，即使几个版本过后再优化，只要能够通过先前写好的测试用例，就能保证代码质量。

所以说，TDD非常适合快速迭代的节奏，先尽快实现功能，然后再进行重构和优化，如果我们不使用TDD来快速迭代开发，虽然在最开始的时候开发效率比TDD高，但是在几个版本之后进行功能更新时，就需要在功能验证上发费大量的时间，反而得不偿失。

其实，TDD这种开发模式和画漫画的工作方式非常类似：草稿就类似TDD中的测试用例，漫画家先画草稿，细节有漫画家和助手一起完成，无论助手怎么换，有了草稿的保障，内容都不会有偏差，分镜的草稿没有细节，人物眼睛、鼻子都可能没有，场景也只需要几条透视线就可以，虽然没有细节，但是草稿基本就确定了漫画完成后要表达的所有内容。

### BDD

相比TDD，BDD更关注的是行为方式的设计，通过对行为的描述来验证功能的可用性，行为描述使用的DSL，规范、标准而且可读性高，可以当做文档来使用。


BDD 的 Objective-C 框架有 **Kiwi**、**Specta**、**Expecta**等，Swift框架有**Quick**;

Kiwi框架不光有specta的DSL模式，Expecta框架的期望语法，还有Mocks和Stubs这样的模拟存根能力，所以接下来，说说这个iOS中非常出名并且好用的BDD框架，以及怎么用它来进行BDD开发。


#### Kiwi


将Kiwi集成到你的App里，只需要在Podfile里添加pod ‘Kiwi’即可，下面这段代码，是Kiwi的使用示例：

```
// describe 表示要测试的对象
describe(@"RSSListViewController", ^{
    // context 表示的是不同场景下的行为
    context(@"when get RSS data", ^{
        // 同一个 context 下每个 it 调用之前会调用一次 beforeEach
        beforeEach(^{
            id dataStore = [DataStore new];
        });


        // it 表示测试内容，一个 context 可以有多个 it
        it(@"load data", ^{
            // Kiwi 使用链式调用，should 表示一个期待，用来验证对象行为是否满足期望
            [[theValue(dataStore.count) shouldNot] beNil];
        });
    });
});
```


上面这段代码描述的是在RSS列表页面，当获取R说说、数据时去读取数据这个行为的测试用例，这段测试用例代码，包含了kiwi的基本元素，也就是describe、context、it。这些元素间的关系可以表述为：


+ describe 表示要测试的对象，context 表示的是不同场景下的行为，一个 describe 里可以包含多个 context。

+ it 表示的是需要测试的内容，同一个场景下的行为会有多个需要测试的内容，也就是说一个 context 下可以有多个 it。

测试内容使用的Kiwi的DSL语法，采用的是链式调用，上面实例代码中shouldNot是期望语法，期望是用来验证对象行为是否满足期望。


期望语法可以是期望数值和数字，也可以是期望字符串的匹配，比如：

```
[[string should] containString:@"rss"];
```

should containString 语法表示的是，期望 string 包含了 rss 字符串。Kiwi 里的期望语法非常丰富，还有正则表达式匹配、数量变化、对象测试、集合、交互和消息、通知、异步调用、异常等。完整的期望语法描述，你可以查看 Wiki 的 

<a style="color:#fa8919;" href="https://github.com/allending/Kiwi/wiki/Expectations">Expectations 部分</a>

除了期望语法外，Kiwi还支持模拟对象和存根语法。


模拟对象可以降低对象之间的依赖，可以模拟难以出现的情况。模拟对象包含了模拟Null对象，模拟类的实例、模拟协议的实例等，存根可以返回指定选择器或消息模式的请求，可以存根对象和模拟对象。

模拟对象和存根的详细语法定义，你可以查看 Wiki 的 
<a style="color:#fa8919;" href="https://github.com/allending/Kiwi/wiki/Mocks-and-Stubs">Mocks and Stubs 部分</a>


### 小结

按照TDD和BDD方式开发，有助于更好地进行模块化设计，划清模块边界，让代码更容易维护。TDD 在测试用例的保障下更容易进行代码重构优化，减少debug时间，而使用BDD编写的测试用例，则更是好的文档，可读性非常强，通过这些测试用例，在修改代码时，我们能够更好地了解开发App的工作状态，同时，修改完代码后能够快速全面地测试验证问题。

无论是TDD还是BDD，开发中对于每个实现的方法都要编写测试用例，而且要注意先编写测试用例代码，再编写方法实现代码，测试用例需要考虑到各种异常条件，以及输入输出的边界。编写完测试用例还需要检查如果输入为错时，测试用例是否会显示为错。

需要强调的是，好的模块化架构和TDD、BDD是相辅相成的，TDD和BDD开发方式会让你的代码更加模块化，而模块化的架构更容易使用TDD和BDD的方式进行开发。


在团队中推行TDD和BDD的最大困难，就是业务迭代太快时，没有时间去写测试用例。建议是，优先对基础能力的开发使用TDD和BDD，保证了基础能力的稳定，业务怎么变，底子还都是稳固的，当有了业务迭代、有了间隙时，再考虑在核心业务上采用BDD，最大程度的保证App核心功能的稳定。




















